<!doctype html><html lang=ja><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>docker-buildのチューニングTips全部書く【Go×GitHubActions】 &#183; からまるのブログ</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link rel=icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/images/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/images/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/images/ren.jpg><link href rel=alternate type=application/rss+xml title=からまるのブログ><meta property="og:url" content="https://karamaru-alpha.com/posts/docker-build-2025/"><meta property="og:site_name" content="からまるのブログ"><meta property="og:title" content="docker-buildのチューニングTips全部書く【Go×GitHubActions】"><meta property="og:description" content="docker の最新記法や、GitHubActions でのビルドチューニングについて網羅的に書かれている記事って意外と少ない！
主に Go*GitHubActions での image ビルドについて、実行時間を短く・レイヤーを小さくする Tips を共有します 🚀"><meta property="og:locale" content="ja"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-04T12:16:21+09:00"><meta property="article:modified_time" content="2025-12-04T12:16:21+09:00"><meta property="og:image" content="https://karamaru-alpha.com/posts/docker-build-2025/thumbnail.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://karamaru-alpha.com/posts/docker-build-2025/thumbnail.jpg"><meta name=twitter:title content="docker-buildのチューニングTips全部書く【Go×GitHubActions】"><meta name=twitter:description content="docker の最新記法や、GitHubActions でのビルドチューニングについて網羅的に書かれている記事って意外と少ない！
主に Go*GitHubActions での image ビルドについて、実行時間を短く・レイヤーを小さくする Tips を共有します 🚀"><script src=/js/darkmode.js></script></head><body><nav class=nav><div class=nav-container><a href=/><h2 class=nav-title>からまるのブログ</h2></a><ul><li><a href=https://github.com/karamaru-alpha target=_blank rel="noopener noreferrer"><span>GitHub</span></a></li><li><a href=https://x.com/karamaru_alpha target=_blank rel="noopener noreferrer"><span>X</span></a></li><li><a href=https://speakerdeck.com/karamaru target=_blank rel="noopener noreferrer"><span>SpeackerDeck</span></a></li><li><a href=https://sizu.me/karamaru_alpha target=_blank rel="noopener noreferrer"><span>SizuIn</span></a></li><li><a href=https://www.linkedin.com/in/karamaru target=_blank rel="noopener noreferrer"><span>LinkedIn</span></a></li><li><a href=https://karamaru-alpha.com/index.xml target=_blank rel="noopener noreferrer"><span>RSS</span></a></li></ul></div></nav><div id=darkModeToggle onclick=toggleDarkMode()>&#9680;</div><main><div class=post><div class=post-info><span></span><br><span>&nbsp;</span><time datetime="2025-12-04 12:16:21 +0900 +0900">2025/12/04</time></div><h1 class=post-title>docker-buildのチューニングTips全部書く【Go×GitHubActions】</h1><div class=post-line></div><p>docker の最新記法や、GitHubActions でのビルドチューニングについて網羅的に書かれている記事って意外と少ない！</p><p>主に Go*GitHubActions での image ビルドについて、実行時間を短く・レイヤーを小さくする Tips を共有します 🚀</p><h2 id=はじめに>はじめに</h2><p><a href=https://qiita.com/advent-calendar/2025/qualiarts>QualiArts Advent Calendar 2025</a> の 4 日目の記事です！</p><p>皆様の docker-build 改善のきっかけになれるような記事を目指します！どれか刺され！🔥</p><p><strong>目次</strong></p><nav class=toc><nav id=TableOfContents><ul><li><a href=#はじめに>はじめに</a></li><li><a href=#1-dockerignore-を適切に設定する>1. .dockerignore を適切に設定する</a><ul><li><a href=#1-1-レイヤーごとのファイル状況を目視するdive>1-1. レイヤーごとのファイル状況を目視する「dive」</a></li><li><a href=#1-2-buildkit-による自動-ignore>1-2. BuildKit による自動 ignore</a></li></ul></li><li><a href=#2-マルチステージビルドを行う>2. マルチステージビルドを行う</a></li><li><a href=#3-レイヤーキャッシュがヒットしやすい構成にする>3. レイヤーキャッシュがヒットしやすい構成にする</a><ul><li><a href=#3-1-pnpm-におけるレイヤーキャッシュ活用>3-1. pnpm におけるレイヤーキャッシュ活用</a></li><li><a href=#3-2-中間レイヤーの確認と-tar-圧縮について>3-2. 中間レイヤーの確認と tar 圧縮について</a></li></ul></li><li><a href=#4-go-バイナリのシンボルテーブルデバッグ情報を削除する>4. Go バイナリのシンボルテーブル・デバッグ情報を削除する</a><ul><li><a href=#4-1-upx-によるバイナリ圧縮とレイヤー圧縮>4-1. UPX によるバイナリ圧縮とレイヤー圧縮</a></li></ul></li><li><a href=#5-bind-mounts-でレイヤーをスリムにたもつ>5. Bind mounts でレイヤーをスリムにたもつ</a></li><li><a href=#6-cache-mounts-でレイヤーを跨いでキャッシュする>6. Cache mounts でレイヤーを跨いでキャッシュする</a><ul><li></li></ul></li><li><a href=#7-distroless-などの軽量イメージ-を-base-image-に選択する>7. distroless などの軽量イメージ を base-image に選択する</a></li><li><a href=#8-buildkit-の圧縮を-gzip--zstd-に変更する>8. BuildKit の圧縮を Gzip → zstd に変更する</a></li><li><a href=#9-githubactions-のランナーを強化するnamespaceso>9. GitHubActions のランナーを強化する（namespace.so）</a></li><li><a href=#10-その他細かいやつと-hadolint>10. その他細かいやつと hadolint</a></li><li><a href=#まとめ>まとめ</a></li></ul></nav></nav><h2 id=1-dockerignore-を適切に設定する>1. .dockerignore を適切に設定する</h2><p>まずどのように docker がファイルを扱うのかを確認しましょう。</p><p><code>docker build</code>時、docker デーモンに指定ディレクトリ配下のファイルを tar アーカイブとして送信し、これがビルド時に<code>COPY</code>や<code>ADD</code>経由でアクセスできるファイル群（<a href=https://docs.docker.com/build/concepts/context/>BuildContext</a>）になります。</p><figure class=left><img src=https://docs.docker.com/get-started/images/docker-architecture.webp width=300></figure><blockquote><p><a href=https://docs.docker.com/get-started/docker-overview/#docker-architecture>引用</a></p></blockquote><p>そして、<strong><a href=https://docs.docker.com/build/concepts/context/#dockerignore-files>.dockerignore</a>はビルドコンテキストの対象から外すディレクトリ/ファイル一覧を設定できる</strong>仕組みです。これを適切に設定することにより、docker デーモンに転送するファイルサイズが減るのはもちろん、レイヤーのサイズも削減できます。</p><p>特に重い<code>.git</code>ファイルや、本番で使うことのない<strong>テスト・ドキュメントファイル</strong>などは特別必要ないのであれば<strong>除外しておきたい</strong>ところですね 🙆</p><div class="highlight small-font75"><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-t data-lang=t><span style=display:flex><span><span style=color:#666>.*</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 再起的にファイルを除外するには*.mdだけでは足りず、**/指定が必要なので注意</span>
</span></span><span style=display:flex><span><span style=color:#666>**/*.</span>md
</span></span><span style=display:flex><span><span style=color:#666>**/*</span>_test<span style=color:#666>.</span>go
</span></span></code></pre></div><p>これを活用して <a href=https://www.infracost.io/>infracost</a> という terraform からコスト差分を検出できる CLI へ OSS コミットできたりしました 👏</p><figure class=left><img src=/posts/docker-build-2025/infracost2.jpg width=300></figure><p>cf. <a href=https://github.com/infracost/infracost/pull/3480>https://github.com/infracost/infracost/pull/3480</a></p><h3 id=1-1-レイヤーごとのファイル状況を目視するdive>1-1. レイヤーごとのファイル状況を目視する「dive」</h3><p><a href=https://github.com/wagoodman/dive>dive</a>はレイヤーごとに image のファイル状況を可視化できる神ツールです。</p><p>上記 PR も<code>dive ${image_tag}</code>の結果を参考にしたもので、<code>COPY . .</code>で本来必要のない<code>testdata</code>ディレクトリが余計に容量を圧迫していることが分かりますね。</p><figure class=left><img src=/posts/docker-build-2025/infracost3.jpg width=800></figure><p>定期的に image の中身を dive で確認し、必要ないものが入っていないか精査することをお勧めします 🙆</p><h3 id=1-2-buildkit-による自動-ignore>1-2. BuildKit による自動 ignore</h3><p>「<strong>私の<code>.dockerignore</code>薄すぎ&mldr;？</strong>」と思った人も大丈夫。救済があります。</p><p><a href=https://docs.docker.com/build/buildkit/><strong>BuildKit</strong></a>は<a href=https://docs.docker.com/build/>DockerBuild</a>の拡張ツールで、現在は本体のデフォルト機能として取り込まれています。BuildKit には、<strong>明示的にアクセスがないファイルは自動的にビルドコンテキストの対象から除外する</strong>機能が導入されています 👏</p><blockquote><p>Detect and skip transferring unused files in your build context</p></blockquote><p>例えば<code>COPY dir_A .</code>のみの Dockerfile なら、<code>dir_A</code>以外のディレクトリは BuildContext に送信しないようにしてくれる感じですね！私たちは恵まれた時代に生きています。</p><p>一方、<code>dir_A</code>の<strong>中にある不要ファイルの除外は行ってくれません</strong>し、<code>COPY . .</code>と記述していたら問答無用で全て転送されてしまいます。</p><p>BuildContext から取得するファイルの範囲を<strong>必要最小限に記述</strong>した上で、<strong><code>.dockerignore</code>も適切に設定</strong>するのが好ましいでしょう。</p><h2 id=2-マルチステージビルドを行う>2. マルチステージビルドを行う</h2><p>正直耳タコな話ですが一応記述します。</p><p>参照時は最終ステージのみが配信されるため、ビルド環境の配信環境はステージを切り分け、<strong>成果物だけ最終ステージに残すことでイメージサイズを落とす</strong>テクニックでしたね。</p><p><a href=https://docs.docker.com/build/building/multi-stage/>公式の例示</a>では以下のような結果となりました。</p><div class="highlight small-font50"><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1</span><span>FROM golang:1.24
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2</span><span>WORKDIR /src
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3</span><span>COPY &lt;&lt;EOF ./main.go
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4</span><span>package main
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6</span><span>import &#34;fmt&#34;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8</span><span>func main() {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9</span><span>  fmt.Println(&#34;hello, world&#34;)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10</span><span>}
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11</span><span>EOF
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12</span><span>RUN go build -o /bin/hello ./main.go
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14</span><span><span style=color:#00a000>+ FROM scratch
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15</span><span><span style=color:#00a000>+ COPY --from=0 /bin/hello /bin/hello
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16</span><span><span style=color:#00a000></span>CMD [&#34;/bin/hello&#34;]
</span></span></code></pre></div><div class="highlight small-font75"><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>$ docker images hoge --format &#34;{{.Size}}&#34;
</span></span><span style=display:flex><span><span style=color:#a00000>- // 1.37GB
</span></span></span><span style=display:flex><span><span style=color:#a00000></span><span style=color:#00a000>+ // 3.47MB
</span></span></span></code></pre></div><p>ちなみに、<a href=https://docs.docker.com/build/buildkit/><strong>BuildKit</strong></a>には各ステージを並列ビルドしてくれる機能も備わっています。</p><blockquote><p>Parallelize building independent build stages</p></blockquote><p>弊プロジェクトはかつて <a href=https://github.com/GoogleContainerTools/kaniko>kaniko</a>(2025/06 にアーカイブ)を使っており、これは<a href=https://github.com/GoogleContainerTools/kaniko/issues/3444>ステージごとの並列ビルドに対応していなかった</a>ため、乗り換えるだけでビルド時間短縮の恩恵が得られました。</p><h2 id=3-レイヤーキャッシュがヒットしやすい構成にする>3. レイヤーキャッシュがヒットしやすい構成にする</h2><p>耳タコな話が続きますが、まずは<strong>レイヤーキャッシュ</strong>についてのおさらいからです。</p><p>Dockerfile 内の各命令（<code>RUN</code>、<code>COPY</code>など）はそれぞれ独立した「レイヤー」を作成し、ファイルシステムの変更差分（diff）として積み重ねられていく構造になっています。</p><p>ビルド実行時、Docker は各レイヤーに対して、命令とファイル内容のチェックサムが同じか判定し、同じならそのレイヤーは再実行されずキャッシュから取得される。
<strong>キャッシュが無効なレイヤーが挟まるとそれ以降のレイヤーは全て再実行される</strong>点が重要です。</p><figure class=left><img src=https://docs.docker.com/build/images/cache-stack-invalidated.png width=500></figure><blockquote><p><a href=https://docs.docker.com/build/cache/#how-the-build-cache-works>引用</a></p></blockquote><p>よって、変更の少ない && 実行時間がかかる処理を前半に記述し、変更の多い処理を後半に記述するのが鉄則になります。</p><p>Go 言語であれば、モジュールのダウンロードを先んじて切り出すことで、アプリケーションロジックのみの変更があった際、モジュールの DL レイヤーをスキップできます。</p><div class="highlight small-font75"><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#00a000>+ COPY go.mod go.sum .
</span></span></span><span style=display:flex><span><span style=color:#00a000>+ RUN go mod download
</span></span></span><span style=display:flex><span><span style=color:#00a000></span>  COPY . .
</span></span><span style=display:flex><span>  RUN go build main.go
</span></span></code></pre></div><p>cf. <a href=https://docs.docker.com/build/cache/optimize/#order-your-layers>https://docs.docker.com/build/cache/optimize/#order-your-layers</a></p><h3 id=3-1-pnpm-におけるレイヤーキャッシュ活用>3-1. pnpm におけるレイヤーキャッシュ活用</h3><p>蛇足ですが、pnpm の場合も同じようなことが言えます。</p><p><code>package.json</code>ファイルは変更されたが<code>pnpm-lock</code>ファイルが変更されない(依存関係が変わらない)場合に、依存のダウンロードをスキップして<code>store</code>ディレクトリの<code>cache</code>を用いることができます。</p><div class="highlight small-font75"><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#00a000>+ COPY pnpm-lock.yaml target=pnpm-lock.yaml .
</span></span></span><span style=display:flex><span><span style=color:#00a000>+ RUN pnpm fetch --frozen-lockfile
</span></span></span><span style=display:flex><span><span style=color:#00a000>+ COPY package.json .
</span></span></span><span style=display:flex><span><span style=color:#00a000>+ RUN pnpm install --offline --frozen-lockfile
</span></span></span><span style=display:flex><span><span style=color:#00a000></span>  COPY . .
</span></span><span style=display:flex><span>  RUN pnpm build:hoge
</span></span></code></pre></div><p><code>pnpm fetch</code>、最近知りました。便利です。</p><p>cf. <a href=https://pnpm.io/ja/cli/fetch>https://pnpm.io/ja/cli/fetch</a></p><h3 id=3-2-中間レイヤーの確認と-tar-圧縮について>3-2. 中間レイヤーの確認と tar 圧縮について</h3><p>ちなみに、中間レイヤーのサイズや MediaType は<a href=https://github.com/google/go-containerregistry/tree/main/cmd/crane>crane</a>というツールを使うことで確認できます。</p><div class="highlight small-font50"><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ crane manifest --platform linux/amd64 nginx:1.29.3-alpine
</span></span><span style=display:flex><span><span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:#b44>&#34;schemaVersion&#34;</span>: 2,
</span></span><span style=display:flex><span>  <span style=color:#b44>&#34;mediaType&#34;</span>: <span style=color:#b44>&#34;application/vnd.oci.image.manifest.v1+json&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#b44>&#34;config&#34;</span>: <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;mediaType&#34;</span>: <span style=color:#b44>&#34;application/vnd.oci.image.config.v1+json&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;digest&#34;</span>: <span style=color:#b44>&#34;sha256:d4918ca78576a537caa7b0c043051c8efc1796de33fee8724ee0fff4a1cabed9&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;size&#34;</span>: <span style=color:#666>10963</span>
</span></span><span style=display:flex><span>  <span style=color:#666>}</span>,
</span></span><span style=display:flex><span>  <span style=color:#b44>&#34;layers&#34;</span>: <span style=color:#666>[</span>
</span></span><span style=display:flex><span>    <span style=color:#666>{</span>
</span></span><span style=display:flex><span>      <span style=color:#b44>&#34;mediaType&#34;</span>: <span style=color:#b44>&#34;application/vnd.oci.image.layer.v1.tar+gzip&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:#b44>&#34;digest&#34;</span>: <span style=color:#b44>&#34;sha256:2d35ebdb57d9971fea0cac1582aa78935adf8058b2cc32db163c98822e5dfa1b&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:#b44>&#34;size&#34;</span>: <span style=color:#666>3802452</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>,
</span></span><span style=display:flex><span>    <span style=color:#666>{</span>
</span></span><span style=display:flex><span>      <span style=color:#b44>&#34;mediaType&#34;</span>: <span style=color:#b44>&#34;application/vnd.oci.image.layer.v1.tar+gzip&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:#b44>&#34;digest&#34;</span>: <span style=color:#b44>&#34;sha256:8f6a6833e95d43ac524f1f9c5e7c1316c1f3b8e7ae5ba3db4e54b0c5b910e80a&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:#b44>&#34;size&#34;</span>: <span style=color:#666>1835502</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>,
</span></span><span style=display:flex><span>	...
</span></span></code></pre></div><p>ここから、この image の中間レイヤーが Gzip で圧縮されていることが分かったりします（後で使うから覚えておいて！）。</p><p>cf. <a href=https://github.com/opencontainers/image-spec/blob/v1.1.0/layer.md#gzip-media-types>https://github.com/opencontainers/image-spec/blob/v1.1.0/layer.md#gzip-media-types</a></p><h2 id=4-go-バイナリのシンボルテーブルデバッグ情報を削除する>4. Go バイナリのシンボルテーブル・デバッグ情報を削除する</h2><p>少し寄り道して、Go バイナリを小さくする話もします。</p><p><code>go build</code>時に <strong><code>ldflags</code>で<code>-s</code>を指定するとシンボルテーブルなどのデバッグ情報が削除</strong>されバイナリサイズを削減できます。
ビルド環境のローカルパス情報を隠蔽する<code>-trimpath</code>と並び、Gopher なら 2 億回目にするやつですね</p><p>Hello World で試すと以下のような差分になりました。</p><div class="highlight small-font75"><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#a00000>- go build main.go &amp;&amp; du -h main // 2.3M
</span></span></span><span style=display:flex><span><span style=color:#a00000></span><span style=color:#00a000>+ go build -trimpath -ldflags=&#34;-s&#34; main.go &amp;&amp; du -h main // 1.5M
</span></span></span></code></pre></div><p>ちなみに、昔はよく<code>-s -w</code>という記法を見ましたが、<a href=https://github.com/golang/go/commit/ba1deb1ceef956bdb3ca5a9570f132cf19ccc9f6><strong>Go1.22 からは-s のみで完結</strong></a>するようになっています。</p><p>このような昔からある話でも意外と OSS commit チャンスがあったりするのでおすすめです 🎉</p><p><figure class=left><img src=/posts/docker-build-2025/infracost1.jpg width=300></figure>cf. <a href=https://github.com/infracost/infracost/pull/3479>https://github.com/infracost/infracost/pull/3479</a></p><h3 id=4-1-upx-によるバイナリ圧縮とレイヤー圧縮>4-1. UPX によるバイナリ圧縮とレイヤー圧縮</h3><p>さらに脱線して、Go バイナリの圧縮について検討してみましょう。</p><p><a href=https://github.com/upx/upx>UPX</a>は実行ファイルを圧縮するツールです。
圧縮されたファイルは自身の展開プログラムもバイナリに含むため、ユーザーが外から展開処理を記述する必要がなく非常にスマートです。</p><p>Hello World のバイナリサイズは UPX を噛ませることでこんなに小さくなります。</p><div class="highlight small-font75"><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#a00000>- go build -trimpath -ldflags=&#34;-s&#34; main.go &amp;&amp; du -h main
</span></span></span><span style=display:flex><span><span style=color:#a00000>- // 1.5M
</span></span></span><span style=display:flex><span><span style=color:#a00000></span><span style=color:#00a000>+ go build -trimpath -ldflags=&#34;-s&#34; main.go &amp;&amp; upx -q --force-macos main &amp;&amp; du -h main
</span></span></span><span style=display:flex><span><span style=color:#00a000>+ // 676K
</span></span></span></code></pre></div><p>さて、<strong>UPX を Dockerfile 内で行う必要があるのか</strong>という議論が面白のいです。</p><p>先述した通り、<strong>レイヤーは通常 tar.gz （Gzip）で圧縮</strong>されるため、部分的に <strong>2 重圧縮となり効率が悪くなる</strong>ケースが存在します。
また、そもそも自身の展開プログラムが余分にバイナリに入っていたりする影響で、<strong>思うように image サイズが下がらない</strong>場合がままあるようです。</p><p>かなりハッキーなので、一旦は UPX は使わないでよさそうという結論に着地しましょう。</p><h4 id=スーパー面白記事紹介コーナー>スーパー面白記事紹介コーナー</h4><p>以下記事がとても勉強になりました、ありがとうございました。 <a href=https://x.com/knqyf263>@knqyf263</a></p><p>cf. <a href=https://future-architect.github.io/articles/20210520b/>コンテナイメージ内の実行ファイルを upx で圧縮するべきか | フューチャー技術ブログ</a></p><h2 id=5-bind-mounts-でレイヤーをスリムにたもつ>5. Bind mounts でレイヤーをスリムにたもつ</h2><p>さて、Docker に話を戻しましょう。</p><p>今までは<code>COPY</code>命令で必要なファイルを BuildContext に移植した上でビルドしていましたが、本質的にはレイヤーの成果物として欲しいのはビルドの成果物だけで、それに必要なファイル群はビルドが終わってしまえばレイヤーに保持しておく必要ありません。</p><p><a href=https://docs.docker.com/engine/storage/bind-mounts/><strong>Bind mounts</strong></a>は、BuildContext のファイルを命令の間だけ image にマウントする機能です。</p><div class="highlight small-font75"><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#a00000>- COPY main.go .
</span></span></span><span style=display:flex><span><span style=color:#a00000>- RUN go build -o /bin/hello ./main.go
</span></span></span><span style=display:flex><span><span style=color:#a00000></span><span style=color:#00a000>+ RUN --mount=source=main.go,target=main.go \
</span></span></span><span style=display:flex><span><span style=color:#00a000>+  	go build -o /bin/hello ./main.go
</span></span></span></code></pre></div><p>右が Bind mounts を活用した image です。</p><p>ビルドのみに必要な<code>main.go</code>というファイル が中間レイヤーに入り込まないことを確認できます 👏<figure class=left><img src=/posts/docker-build-2025/bind-mount.jpg width=700></figure></p><p>たとえ最終ステージでなくても、レイヤーのサイズは小さいに越したことはないです。</p><p>ランタイムでファイルの参照があるなど特別な理由がない限り、Go 言語では <strong><code>COPY</code>や<code>ADD</code>を使わなくていい時代</strong>になったのは少しだけ大きな転換点でしたね 🚀</p><h2 id=6-cache-mounts-でレイヤーを跨いでキャッシュする>6. Cache mounts でレイヤーを跨いでキャッシュする</h2><p>次に、<strong>レイヤーキャッシュが無効な状態でもビルドキャッシュなどを個別に活用</strong>する方法についてです。</p><p><a href=https://docs.docker.com/build/cache/optimize/#use-cache-mounts><strong>Cache mounts</strong></a>は、ビルドを超えたキャッシュ置き場フォルダを指定する機能です。たとえレイヤーキャッシュが効かなくても、2 回目以降のビルドであれば前回の module/build キャッシュを活用することができます。</p><div class="highlight small-font75"><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#00a000>+ RUN --mount=type=cache,target=/go/pkg/mod \
</span></span></span><span style=display:flex><span><span style=color:#00a000></span>      --mount=source=go.mod,target=go.mod \
</span></span><span style=display:flex><span>      --mount=source=go.sum,target=go.sum \
</span></span><span style=display:flex><span>      go mod download
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00a000>+ RUN --mount=type=cache,target=/root/.cache/go-build \
</span></span></span><span style=display:flex><span><span style=color:#00a000>+     --mount=type=cache,target=/go/pkg/mod \
</span></span></span><span style=display:flex><span><span style=color:#00a000></span>      --mount=source=go.mod,target=go.mod \
</span></span><span style=display:flex><span>      --mount=source=go.sum,target=go.sum \
</span></span><span style=display:flex><span>      --mount=source=cmd/api,target=cmd/api \
</span></span><span style=display:flex><span>      CGO_ENABLED=0 go build -o api -trimpath -ldflags &#39;-s -w&#39; cmd/api/main.go
</span></span></code></pre></div><p>私が所属するプロジェクトのある image では、<strong>Bind/Cache mounts を導入したことでビルド時間が大幅に改善</strong>しました。</p><figure class=left><img src=/posts/docker-build-2025/cache-mount.jpg width=500></figure><p>ちなみに、<a href=https://docs.docker.com/build/ci/github-actions/cache/#cache-mounts>BuildKit はデフォルトで Cache mounts のキャッシュを GitHubActions で使うことができない</a>ため、CI 環境では専用の action「<a href=https://github.com/reproducible-containers/buildkit-cache-dance>buildkit-cache-dance</a>」を使う必要があることに注意が必要です。</p><h4 id=スーパー面白記事紹介コーナー-1>スーパー面白記事紹介コーナー</h4><p>とても勉強になりました、ありがとうございました。<a href=https://x.com/shibu_jp>@shibu_jp</a></p><p>cf. <a href=https://future-architect.github.io/articles/20240726a/>2024 年版の Dockerfile の考え方＆書き方 | フューチャー技術ブログ</a></p><h2 id=7-distroless-などの軽量イメージ-を-base-image-に選択する>7. distroless などの軽量イメージ を base-image に選択する</h2><p>次に、そもそものベースイメージのサイズを小さくします。</p><p><a href=https://github.com/GoogleContainerTools/distroless><strong>distroless</strong></a> は Google が提供している必要最小限の依存のみが含まれる image で、alpine と比較しても軽量且つセキュアであることが特徴です。内容物は以下の通りです。</p><ul><li><a href="https://github.com/GoogleContainerTools/distroless/blob/8795dab120a20242db8a408c886a41f453ae5dde/base/README.md?plain=1#L7-L12">gcr.io/distroless/static</a><ul><li>ca-certificates</li><li>A /etc/passwd entry for a root user</li><li>A /tmp directory</li><li>tzdata</li></ul></li><li><a href="https://github.com/GoogleContainerTools/distroless/blob/8795dab120a20242db8a408c886a41f453ae5dde/base/README.md?plain=1#L19-L24">gcr.io/distroless/base</a><ul><li>distroless/static の内訳</li><li>glibc</li><li>libssl</li></ul></li></ul><p>とりあえず<code>CGO_ENABLED=0</code>で<code>distroless/static</code>に載せてビルドしてみて、ダメだったら base や他の選択肢考える心持ちで良きだと思います 🙆</p><div class="highlight small-font50"><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>FROM golang:1.25.5-alpine3.21 AS builder
</span></span><span style=display:flex><span>WORKDIR /src
</span></span><span style=display:flex><span>COPY . .
</span></span><span style=display:flex><span>RUN CGO_ENABLED=0 go build -o api ./main.go
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a00000>- FROM alpine:3.22.2
</span></span></span><span style=display:flex><span><span style=color:#a00000></span><span style=color:#00a000>+ FROM gcr.io/distroless/static-debian12:nonroot
</span></span></span><span style=display:flex><span><span style=color:#00a000></span>WORKDIR /usr/src/
</span></span><span style=display:flex><span>COPY --from=builder /src/api .
</span></span><span style=display:flex><span>CMD [&#34;/usr/src/api&#34;]
</span></span></code></pre></div><p>単純な http サーバーで検証したところ、以下のようなサイズ削減ができました 👏</p><div class="highlight small-font75"><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>$ docker images hoge --format &#34;{{.Size}}&#34;
</span></span><span style=display:flex><span><span style=color:#a00000>- 25MB
</span></span></span><span style=display:flex><span><span style=color:#a00000></span><span style=color:#00a000>+ 17.9MB
</span></span></span></code></pre></div><h2 id=8-buildkit-の圧縮を-gzip--zstd-に変更する>8. BuildKit の圧縮を Gzip → zstd に変更する</h2><p>次に、レイヤーの圧縮手法についてです。
先述した通り、<strong>通常レイヤーは Gzip 圧縮されますが、実は zstd で圧縮することもできます</strong>。</p><p>圧縮レベルにもよりますが、zstd は Gzip に比べ比較的圧縮率が高く、必要時間も短い、展開速度も同程度ということで、乗り換えることによるデメリットはあまりなさそうでした。</p><p><a href=https://github.com/docker/build-push-action>docker/build-push-action</a>は GitHubActions で docker-build する際のデファクトスタンダードで、こちらで検証してみましょう。</p><div class="highlight small-font50"><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>  - name: Build and push Docker image
</span></span><span style=display:flex><span>    uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 # v6.18.0
</span></span><span style=display:flex><span>    with:
</span></span><span style=display:flex><span>      context: .
</span></span><span style=display:flex><span>      file: ${{ needs.init.outputs.docker_file }}
</span></span><span style=display:flex><span><span style=color:#a00000>-     push: true
</span></span></span><span style=display:flex><span><span style=color:#a00000></span><span style=color:#00a000>+     outputs: type=registry,oci-mediatypes=true,compression=zstd,compression-level=3,force-compression=true
</span></span></span><span style=display:flex><span><span style=color:#00a000></span>      tags: ${{ inputs.location }}-docker.pkg.dev/${{ env.GOOGLE_CLOUD_PROJECT }}/${{ inputs.repository_name }}/${{ inputs.target }}:${{ needs.init.outputs.image_tag_name }}
</span></span><span style=display:flex><span>      platforms: linux/amd64
</span></span><span style=display:flex><span>      cache-from: |
</span></span><span style=display:flex><span>        type=registry,ref=${{ inputs.location }}-docker.pkg.dev/${{ env.GOOGLE_CLOUD_PROJECT }}/${{ inputs.repository_name }}/${{ inputs.target }}/cache:latest
</span></span><span style=display:flex><span>      cache-to: |
</span></span><span style=display:flex><span><span style=color:#a00000>-       type=registry,ref=${{ inputs.location }}-docker.pkg.dev/${{ env.GOOGLE_CLOUD_PROJECT }}/${{ inputs.repository_name }}/${{ inputs.target }}/cache:latest,mode=max
</span></span></span><span style=display:flex><span><span style=color:#a00000></span><span style=color:#00a000>+       type=registry,ref=${{ inputs.location }}-docker.pkg.dev/${{ env.GOOGLE_CLOUD_PROJECT }}/${{ inputs.repository_name }}/${{ inputs.target }}/cache:latest,mode=max,oci-mediatypes=true,compression=zstd,compression-level=3,force-compression=true
</span></span></span><span style=display:flex><span><span style=color:#00a000></span>      provenance: false
</span></span><span style=display:flex><span>      sbom: false
</span></span></code></pre></div><blockquote><p>oci-mediatypes=true</p></blockquote><p><a href=https://github.com/opencontainers/image-spec/blob/v1.1.0/layer.md#zstd-media-types>OCI 準拠</a>でビルドする。</p><blockquote><p>force-compression=true</p></blockquote><p>中間レイヤーも強制的に圧縮する</p><blockquote><p>compression-level=3</p></blockquote><p><a href=https://aws.amazon.com/jp/blogs/news/reducing-aws-fargate-startup-times-with-zstd-compressed-container-images/>AWS-fagate のベストプラクティス</a>に準拠した圧縮レベルを採用。</p><div class="highlight small-font50"><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>compression-level=3 – zstd には 22 段階の圧縮レベルがあります。圧縮レベルが高いほど、コンテナイメージのサイズは小さくなりますが、イメージレイヤーを解凍するための CPU リソースも増加します。AWS Fargate の起動時間を短縮するには、ワークロードの開始前にイメージレイヤーをダウンロードして解凍する必要がありますが、最高レベルの圧縮が最速の AWS Fargate の起動時間をもたらすとは限りません。最適な圧縮レベルを見つけるために、自身のコンテナイメージで検証すると良いでしょう。私たちのテストでは、圧縮レベル 3 が最適でした。
</span></span></code></pre></div><p>私の所属するプロジェクトのとある image では、この<strong>圧縮方法の変更だけで 20%サイズが削減</strong>されました 🚀</p><figure class=left><img src=/posts/docker-build-2025/cache-mount.jpg width=300></figure><p>また、ArtifactRegisty の画面から中間レイヤーが OCI 準拠で zstd されていることを確認できました。</p><figure class=left><img src=/posts/docker-build-2025/zstd2.jpg width=300></figure><h2 id=9-githubactions-のランナーを強化するnamespaceso>9. GitHubActions のランナーを強化する（namespace.so）</h2><p>最後に、<strong>実行環境を強くする</strong>というシンプルだけど最も効果的な方法です 🚀</p><p><a href=https://docs.github.com/ja/actions/concepts/runners/github-hosted-runners>GitHub ホステッドランナー</a>の性能をあげてもいいし、自前で CloudRunWorkerPool などで<a href=https://docs.github.com/ja/actions/concepts/runners/self-hosted-runners>セルフホステッドランナー</a>を立ててもいいでしょう。</p><p>今回は、お得でハイスペックなセルフホステッドランナーを SaaS で建てられる<a href=https://namespace.so/><strong>namespace.so</strong></a>を紹介します。</p><p>namespace の最も素晴らしい機能は<a href=https://namespace.so/docs/architecture/storage/cache-volumes><strong>Cache Volumes</strong></a>です。
<strong>キャッシュデータをネットワーク越しにアップロード・ダウンロードするのではなく、ボリュームを物理的にアタッチ</strong>することで、キャッシュの I/O による遅延が大幅に改善されます。</p><p>namspace 専用 action に置き換えると以下になります。<strong>cache の registry 設定が必要なくなっている</strong>ことに注目です。</p><div class="highlight small-font50"><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>  - name: Set up Docker Buildx
</span></span><span style=display:flex><span><span style=color:#a00000>-   uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435 # v3.11.1
</span></span></span><span style=display:flex><span><span style=color:#a00000></span><span style=color:#00a000>+   uses: namespacelabs/nscloud-setup-buildx-action@7020d7d8e659afecbfec162ab4693c7e56278311 # v0.0.19
</span></span></span><span style=display:flex><span><span style=color:#00a000></span>
</span></span><span style=display:flex><span>  # (中略)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  - name: Build and push Docker image
</span></span><span style=display:flex><span>    uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 # v6.18.0
</span></span><span style=display:flex><span>    with:
</span></span><span style=display:flex><span>      context: .
</span></span><span style=display:flex><span>      file: ${{ needs.init.outputs.docker_file }}
</span></span><span style=display:flex><span>      outputs: type=registry,oci-mediatypes=true,compression=zstd,compression-level=3,force-compression=true
</span></span><span style=display:flex><span>      tags: ${{ inputs.location }}-docker.pkg.dev/${{ env.GOOGLE_CLOUD_PROJECT }}/${{ inputs.repository_name }}/${{ inputs.target }}:${{ needs.init.outputs.image_tag_name }}
</span></span><span style=display:flex><span>      platforms: linux/amd64
</span></span><span style=display:flex><span><span style=color:#a00000>-     cache-from: |
</span></span></span><span style=display:flex><span><span style=color:#a00000>-       type=registry,ref=${{ inputs.location }}-docker.pkg.dev/${{ env.GOOGLE_CLOUD_PROJECT }}/${{ inputs.repository_name }}/${{ inputs.target }}/cache:latest
</span></span></span><span style=display:flex><span><span style=color:#a00000>-     cache-to: |
</span></span></span><span style=display:flex><span><span style=color:#a00000>-       type=registry,ref=${{ inputs.location }}-docker.pkg.dev/${{ env.GOOGLE_CLOUD_PROJECT }}/${{ inputs.repository_name }}/${{ inputs.target }}/cache:latest,mode=max,oci-mediatypes=true,compression=zstd,compression-level=3,force-compression=true
</span></span></span><span style=display:flex><span><span style=color:#a00000></span>      provenance: false
</span></span><span style=display:flex><span>      sbom: false
</span></span></code></pre></div><p>弊プロジェクトでは、この移行で CI の実行時間が訳半分に減少しました 👏</p><p>cf. <a href=https://namespace.so/docs/solutions/github-actions/docker-builds#skip-github-actions-caching>https://namespace.so/docs/solutions/github-actions/docker-builds#skip-github-actions-caching</a></p><p>セルフホステッドランナーの SaaS は <a href=https://www.blacksmith.sh/>blacksmith</a>なども候補ですかね。
namespace 程の最適化があるのかは存じ上げませんが、ぜひ色々検討してみてください 🙆</p><p>年間契約などで性能が上がったのにお得になるみたいな減少が起こるかもしれません ☺️</p><h2 id=10-その他細かいやつと-hadolint>10. その他細かいやつと hadolint</h2><p>他にもレイヤーサイズの削減として、<a href=https://github.com/infracost/infracost/pull/3481>apt のキャッシュを削除したり</a></p><div class="highlight small-font50"><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#a00000>- RUN apt-get update -q &amp;&amp; apt-get -y install unzip
</span></span></span><span style=display:flex><span><span style=color:#a00000></span><span style=color:#00a000>+ RUN apt-get update -q &amp;&amp; apt-get -y install unzip &amp;&amp; rm -rf /var/lib/apt/lists/*
</span></span></span></code></pre></div><p>apk の cache を削除したり</p><div class="highlight small-font50"><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#a00000>- RUN apk add gcc
</span></span></span><span style=display:flex><span><span style=color:#a00000></span><span style=color:#00a000>+ RUN apk --no-cache add gcc
</span></span></span></code></pre></div><p>色々なテクニックがありそうですね。</p><p>Dockerfile の品質を保つためにも、定期的に<a href=https://github.com/hadolint/hadolint>hadolint</a>で静的解析を行うことをお勧めします 🙆</p><h2 id=まとめ>まとめ</h2><p>いかがだったでしょうか？</p><p>数字がちゃんと出るパフォーマンスチューニングって楽しいですよね！🚀</p><p>このブログをきっかけに、皆様のプロジェクトの改善のきっかけになれば幸いです。</p><p>ではまた！</p></div><div class=pagination><a href=/posts/gocon2025/ class="left arrow">&#8592;</a>
<a href=# class=top>Top</a></div></main><footer><span>&copy; <time datetime="2025-12-04 07:15:18.07712913 +0000 UTC m=+0.092165321">2025</time> . Made with <a href=https://gohugo.io>Hugo</a> using the <a href=https://github.com/EmielH/tale-hugo/>Tale</a> theme.</span></footer></body></html>